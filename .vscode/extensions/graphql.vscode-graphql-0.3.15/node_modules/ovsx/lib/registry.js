"use strict";
/********************************************************************************
 * Copyright (c) 2019 TypeFox and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const https = require("https");
const fs = require("fs");
const querystring = require("querystring");
const util_1 = require("./util");
exports.DEFAULT_URL = 'https://open-vsx.org';
class Registry {
    constructor(options = {}) {
        if (options.url && options.url.endsWith('/'))
            this.url = options.url.substring(0, options.url.length - 1);
        else if (options.url)
            this.url = options.url;
        else
            this.url = exports.DEFAULT_URL;
    }
    createNamespace(name, pat) {
        try {
            const query = { token: pat };
            const url = this.getUrl('api/-/namespace/create', query);
            const namespace = { name };
            return this.post(JSON.stringify(namespace), url, {
                'Content-Type': 'application/json'
            });
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    publish(file, pat) {
        try {
            const query = { token: pat };
            const url = this.getUrl('api/-/publish', query);
            return this.postFile(file, url, {
                'Content-Type': 'application/octet-stream'
            });
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    getMetadata(namespace, extension) {
        try {
            const path = `api/${encodeURIComponent(namespace)}/${encodeURIComponent(extension)}`;
            return this.getJson(this.getUrl(path));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    download(file, url) {
        return new Promise((resolve, reject) => {
            const stream = fs.createWriteStream(file);
            const request = this.getProtocol(url)
                .request(url, response => {
                response.on('end', () => {
                    if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode > 299)) {
                        reject(util_1.statusError(response));
                    }
                    else {
                        resolve();
                    }
                });
                response.pipe(stream);
            });
            stream.on('error', err => {
                request.abort();
                reject(err);
            });
            request.on('error', err => {
                stream.close();
                reject(err);
            });
            request.end();
        });
    }
    getJson(url) {
        return new Promise((resolve, reject) => {
            const request = this.getProtocol(url)
                .request(url, this.getJsonResponse(resolve, reject));
            request.on('error', reject);
            request.end();
        });
    }
    post(content, url, headers) {
        return new Promise((resolve, reject) => {
            const request = this.getProtocol(url)
                .request(url, { method: 'POST', headers }, this.getJsonResponse(resolve, reject));
            request.on('error', reject);
            request.write(content);
            request.end();
        });
    }
    postFile(file, url, headers) {
        return new Promise((resolve, reject) => {
            const stream = fs.createReadStream(file);
            const request = this.getProtocol(url)
                .request(url, { method: 'POST', headers }, this.getJsonResponse(resolve, reject));
            stream.on('error', err => {
                request.abort();
                reject(err);
            });
            request.on('error', err => {
                stream.close();
                reject(err);
            });
            stream.on('open', () => stream.pipe(request));
        });
    }
    getUrl(path, query) {
        const url = new URL(this.url);
        url.pathname += path;
        if (query) {
            url.search = querystring.stringify(query);
        }
        return url;
    }
    getProtocol(url) {
        if (url.protocol === 'https:')
            return https;
        else
            return http;
    }
    getJsonResponse(resolve, reject) {
        return response => {
            response.setEncoding('UTF-8');
            let json = '';
            response.on('data', chunk => json += chunk);
            response.on('end', () => {
                if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode > 299)) {
                    if (json.startsWith('{')) {
                        try {
                            const error = JSON.parse(json);
                            if (error.message) {
                                reject(new Error(error.message));
                                return;
                            }
                        }
                        catch (err) { }
                    }
                    reject(util_1.statusError(response));
                }
                else if (json.startsWith('<!DOCTYPE html>')) {
                    reject(json);
                }
                else {
                    try {
                        resolve(JSON.parse(json));
                    }
                    catch (err) {
                        reject(err);
                    }
                }
            });
        };
    }
}
exports.Registry = Registry;
