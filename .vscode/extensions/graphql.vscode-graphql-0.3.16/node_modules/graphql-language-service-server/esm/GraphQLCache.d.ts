import { ASTNode } from 'graphql/language';
import type { CachedContent, GraphQLCache as GraphQLCacheInterface, GraphQLFileMetadata, GraphQLFileInfo, FragmentInfo, ObjectTypeInfo, Uri } from 'graphql-language-service';
import { GraphQLSchema } from 'graphql';
import { GraphQLConfig, GraphQLProjectConfig } from 'graphql-config';
import { parseDocument } from './parseDocument';
import { LoadConfigOptions } from './types';
export declare function getGraphQLCache({ parser, loadConfigOptions, config, }: {
    parser: typeof parseDocument;
    loadConfigOptions: LoadConfigOptions;
    config?: GraphQLConfig;
}): Promise<GraphQLCache>;
export declare class GraphQLCache implements GraphQLCacheInterface {
    _configDir: Uri;
    _graphQLFileListCache: Map<Uri, Map<string, GraphQLFileInfo>>;
    _graphQLConfig: GraphQLConfig;
    _schemaMap: Map<Uri, GraphQLSchema>;
    _typeExtensionMap: Map<Uri, number>;
    _fragmentDefinitionsCache: Map<Uri, Map<string, FragmentInfo>>;
    _typeDefinitionsCache: Map<Uri, Map<string, ObjectTypeInfo>>;
    _parser: typeof parseDocument;
    constructor({ configDir, config, parser, }: {
        configDir: Uri;
        config: GraphQLConfig;
        parser: typeof parseDocument;
    });
    getGraphQLConfig: () => GraphQLConfig;
    getProjectForFile: (uri: string) => GraphQLProjectConfig;
    getFragmentDependencies: (query: string, fragmentDefinitions?: Map<string, FragmentInfo> | null | undefined) => Promise<FragmentInfo[]>;
    getFragmentDependenciesForAST: (parsedQuery: ASTNode, fragmentDefinitions: Map<string, FragmentInfo>) => Promise<FragmentInfo[]>;
    getFragmentDefinitions: (projectConfig: GraphQLProjectConfig) => Promise<Map<string, FragmentInfo>>;
    getObjectTypeDependencies: (query: string, objectTypeDefinitions?: Map<string, ObjectTypeInfo> | undefined) => Promise<Array<ObjectTypeInfo>>;
    getObjectTypeDependenciesForAST: (parsedQuery: ASTNode, objectTypeDefinitions: Map<string, ObjectTypeInfo>) => Promise<Array<ObjectTypeInfo>>;
    getObjectTypeDefinitions: (projectConfig: GraphQLProjectConfig) => Promise<Map<string, ObjectTypeInfo>>;
    _readFilesFromInputDirs: (rootDir: string, documents: GraphQLProjectConfig['documents']) => Promise<Array<GraphQLFileMetadata>>;
    _updateGraphQLFileListCache(graphQLFileMap: Map<Uri, GraphQLFileInfo>, metrics: {
        size: number;
        mtime: number;
    }, filePath: Uri, exists: boolean): Promise<Map<Uri, GraphQLFileInfo>>;
    updateFragmentDefinition(rootDir: Uri, filePath: Uri, contents: Array<CachedContent>): Promise<void>;
    updateFragmentDefinitionCache(rootDir: Uri, filePath: Uri, exists: boolean): Promise<void>;
    updateObjectTypeDefinition(rootDir: Uri, filePath: Uri, contents: Array<CachedContent>): Promise<void>;
    updateObjectTypeDefinitionCache(rootDir: Uri, filePath: Uri, exists: boolean): Promise<void>;
    _extendSchema(schema: GraphQLSchema, schemaPath: string | null, schemaCacheKey: string | null): GraphQLSchema;
    getSchema: (appName?: string | undefined, queryHasExtensions?: boolean | null | undefined) => Promise<GraphQLSchema | null>;
    _invalidateSchemaCacheForProject(projectConfig: GraphQLProjectConfig): void;
    _getSchemaCacheKeyForProject(projectConfig: GraphQLProjectConfig): string | {
        [key: string]: any;
    } | import("@graphql-tools/load").UnnormalizedTypeDefPointer[];
    _getProjectName(projectConfig: GraphQLProjectConfig): GraphQLProjectConfig;
    readAllGraphQLFiles: (list: Array<GraphQLFileMetadata>) => Promise<{
        objectTypeDefinitions: Map<string, ObjectTypeInfo>;
        fragmentDefinitions: Map<string, FragmentInfo>;
        graphQLFileMap: Map<string, GraphQLFileInfo>;
    }>;
    processGraphQLFiles: (responses: Array<GraphQLFileInfo>) => {
        objectTypeDefinitions: Map<string, ObjectTypeInfo>;
        fragmentDefinitions: Map<string, FragmentInfo>;
        graphQLFileMap: Map<string, GraphQLFileInfo>;
    };
    promiseToReadGraphQLFile: (filePath: Uri) => Promise<GraphQLFileInfo>;
}
//# sourceMappingURL=GraphQLCache.d.ts.map