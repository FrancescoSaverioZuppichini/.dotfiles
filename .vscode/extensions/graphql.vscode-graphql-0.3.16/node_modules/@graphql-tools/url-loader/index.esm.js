import { __awaiter } from 'tslib';
import { Kind, print } from 'graphql';
import { observableToAsyncIterable } from '@graphql-tools/utils';
import { isWebUri } from 'valid-url';
import { fetch } from 'cross-fetch';
import { introspectSchema, wrapSchema } from '@graphql-tools/wrap';
import { SubscriptionClient } from 'subscriptions-transport-ws';
import { w3cwebsocket } from 'websocket';

/**
 * This loader loads a schema from a URL. The loaded schema is a fully-executable,
 * remote schema since it's created using [@graphql-tools/wrap](/docs/remote-schemas).
 *
 * ```
 * const schema = await loadSchema('http://localhost:3000/graphql', {
 *   loaders: [
 *     new UrlLoader(),
 *   ]
 * });
 * ```
 */
class UrlLoader {
    loaderId() {
        return 'url';
    }
    canLoad(pointer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.canLoadSync(pointer, options);
        });
    }
    canLoadSync(pointer, _options) {
        return !!isWebUri(pointer);
    }
    buildAsyncExecutor({ pointer, fetch, extraHeaders, defaultMethod, useGETForQueries, }) {
        const HTTP_URL = pointer.replace('ws:', 'http:').replace('wss:', 'https:');
        return ({ document, variables }) => __awaiter(this, void 0, void 0, function* () {
            let method = defaultMethod;
            if (useGETForQueries) {
                method = 'GET';
                for (const definition of document.definitions) {
                    if (definition.kind === Kind.OPERATION_DEFINITION) {
                        if (definition.operation !== 'query') {
                            method = defaultMethod;
                        }
                    }
                }
            }
            let fetchResult;
            const query = print(document);
            switch (method) {
                case 'GET':
                    const urlObj = new URL(HTTP_URL);
                    urlObj.searchParams.set('query', query);
                    if (variables && Object.keys(variables).length > 0) {
                        urlObj.searchParams.set('variables', JSON.stringify(variables));
                    }
                    const finalUrl = urlObj.toString();
                    fetchResult = yield fetch(finalUrl, {
                        method: 'GET',
                        headers: extraHeaders,
                    });
                    break;
                case 'POST':
                    fetchResult = yield fetch(HTTP_URL, {
                        method: 'POST',
                        body: JSON.stringify({
                            query,
                            variables,
                        }),
                        headers: extraHeaders,
                    });
                    break;
            }
            return fetchResult.json();
        });
    }
    buildSubscriber(pointer, webSocketImpl) {
        const WS_URL = pointer.replace('http:', 'ws:').replace('https:', 'wss:');
        const subscriptionClient = new SubscriptionClient(WS_URL, {}, webSocketImpl);
        return ({ document, variables }) => __awaiter(this, void 0, void 0, function* () {
            return observableToAsyncIterable(subscriptionClient.request({
                query: document,
                variables,
            }));
        });
    }
    getExecutorAndSubscriber(pointer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let headers = {};
            let fetch$1 = fetch;
            let defaultMethod = 'POST';
            let webSocketImpl = w3cwebsocket;
            if (options) {
                if (Array.isArray(options.headers)) {
                    headers = options.headers.reduce((prev, v) => (Object.assign(Object.assign({}, prev), v)), {});
                }
                else if (typeof options.headers === 'object') {
                    headers = options.headers;
                }
                if (options.customFetch) {
                    if (typeof options.customFetch === 'string') {
                        const [moduleName, fetchFnName] = options.customFetch.split('#');
                        fetch$1 = yield import(moduleName).then(module => (fetchFnName ? module[fetchFnName] : module));
                    }
                    else {
                        fetch$1 = options.customFetch;
                    }
                }
                if (options.webSocketImpl) {
                    if (typeof options.webSocketImpl === 'string') {
                        const [moduleName, webSocketImplName] = options.webSocketImpl.split('#');
                        webSocketImpl = yield import(moduleName).then(module => webSocketImplName ? module[webSocketImplName] : module);
                    }
                    else {
                        webSocketImpl = options.webSocketImpl;
                    }
                }
                if (options.method) {
                    defaultMethod = options.method;
                }
            }
            const extraHeaders = Object.assign({ Accept: 'application/json', 'Content-Type': 'application/json' }, headers);
            const executor = this.buildAsyncExecutor({
                pointer,
                fetch: fetch$1,
                extraHeaders,
                defaultMethod,
                useGETForQueries: options.useGETForQueries,
            });
            let subscriber;
            if (options.enableSubscriptions) {
                subscriber = this.buildSubscriber(pointer, webSocketImpl);
            }
            return {
                executor,
                subscriber,
            };
        });
    }
    getSubschemaConfig(pointer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { executor, subscriber } = yield this.getExecutorAndSubscriber(pointer, options);
            return {
                schema: yield introspectSchema(executor, undefined, options),
                executor,
                subscriber,
            };
        });
    }
    load(pointer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const subschemaConfig = yield this.getSubschemaConfig(pointer, options);
            const remoteExecutableSchema = wrapSchema(subschemaConfig);
            return {
                location: pointer,
                schema: remoteExecutableSchema,
            };
        });
    }
    loadSync() {
        throw new Error('Loader Url has no sync mode');
    }
}

export { UrlLoader };
//# sourceMappingURL=index.esm.js.map
